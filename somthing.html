<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° NEON CHAOS OVERDRIVE ‚ö°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #gameCanvas {
            border: 4px solid #0ff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6), inset 0 0 40px rgba(0, 255, 255, 0.1);
            cursor: crosshair;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
        }
        
        #combo {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ff0;
            text-shadow: 0 0 20px #ff0;
            font-size: 32px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            text-shadow: 0 0 30px #f0f;
            font-size: 48px;
            font-weight: bold;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #0ff;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
            z-index: 100;
            max-width: 700px;
        }
        
        #menu h1 {
            font-size: 48px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff, 0 0 40px #f0f;
            margin-bottom: 20px;
            animation: pulse 2s infinite, rainbow 3s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }
        
        @keyframes rainbow {
            0% { color: #0ff; }
            25% { color: #f0f; }
            50% { color: #ff0; }
            75% { color: #0f0; }
            100% { color: #0ff; }
        }
        
        button {
            background: linear-gradient(45deg, #0ff, #f0f);
            border: none;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            padding: 15px 40px;
            margin: 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(255, 0, 255, 1);
        }
        
        .hidden {
            display: none;
        }
        
        @keyframes blink {
            0%, 50%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div id="stats"></div>
    </div>
    
    <div id="combo"></div>
    <div id="notification"></div>
    
    <div id="menu">
        <h1>‚ö° NEON CHAOS OVERDRIVE ‚ö°</h1>
        <p style="color: #f0f; font-size: 20px; margin-bottom: 20px;">PURE ABSOLUTE INSANITY</p>
        <div style="color: #0ff; margin-bottom: 20px; line-height: 1.8;">
            <p style="font-size: 18px;">üéØ MOUSE AIM & HOLD CLICK TO SHOOT</p>
            <p style="font-size: 18px;">‚å®Ô∏è WASD TO MOVE ‚Ä¢ SPACE FOR ULTIMATE</p>
            <p style="margin-top: 10px; color: #ff0; font-size: 16px;">üî• EVERY GAME IS DIFFERENT! üî•</p>
            <p style="margin-top: 5px; color: #0f0; font-size: 14px;">Get ready for RANDOM CHAOS!</p>
        </div>
        <button onclick="startGame()">‚ñ∂ UNLEASH MAYHEM</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = Math.min(window.innerWidth - 100, 1600);
        canvas.height = Math.min(window.innerHeight - 100, 1000);

        const NEON_COLORS = ['#0ff', '#f0f', '#0f0', '#ff0', '#f08', '#0fa', '#f60', '#80f', '#f06', '#8f0', '#f80', '#0af', '#fa0'];
        
        let gameState = 'menu';
        let keys = {};
        let mouse = { x: canvas.width/2, y: canvas.height/2, down: false };
        let score = 0;
        let bossCount = 0;
        let combo = 0;
        let comboTimer = 0;
        let maxCombo = 0;
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let timeWarp = 1;
        let ultimateCharge = 0;
        let backgroundPulse = 0;
        
        // MASSIVE POWER LIST WITH UNIQUE EFFECTS
        const ALL_POWERS = [
            { name: 'QUAD SHOT', icon: 'üî´', apply: (p) => { p.bulletCount += 4; p.spread = 0.25; } },
            { name: 'HYPER SPEED', icon: '‚ö°', apply: (p) => { p.fireRate *= 0.3; p.speed *= 1.3; } },
            { name: 'ANNIHILATOR', icon: 'üí•', apply: (p) => { p.bulletDamage *= 3; p.bulletSize = 15; } },
            { name: 'SNIPER GOD', icon: 'üéØ', apply: (p) => { p.bulletSpeed *= 2.5; p.bulletDamage *= 2; p.piercing = 999; } },
            { name: 'SHOTGUN MAYHEM', icon: 'üí®', apply: (p) => { p.bulletCount += 8; p.spread = 0.7; p.fireRate *= 1.3; } },
            { name: 'PLASMA CANNON', icon: 'üåü', apply: (p) => { p.laserMode = true; p.laserSize = 25; p.bulletDamage *= 1.5; } },
            { name: 'NUKE LAUNCHER', icon: '‚ò¢Ô∏è', apply: (p) => { p.explosive = true; p.explosionRadius = randomInt(100, 180); } },
            { name: 'SMART MISSILES', icon: 'üöÄ', apply: (p) => { p.homing = true; p.bulletSpeed *= 1.2; } },
            { name: 'FORCE FIELD', icon: 'üõ°Ô∏è', apply: (p) => { p.shield = randomInt(150, 300); p.maxShield = p.shield; p.shieldRegen = 8; } },
            { name: 'FLASH', icon: 'üí®', apply: (p) => { p.speed *= 2.5; p.dashPower = true; } },
            { name: 'JUGGERNAUT', icon: 'üè∞', apply: (p) => { p.maxHp *= 2.5; p.hp *= 2.5; p.size *= 1.4; p.bulletDamage *= 1.5; } },
            { name: 'PHANTOM', icon: 'üëª', apply: (p) => { p.canPhase = true; p.phaseCooldown = 0; p.phaseMax = 0.8; } },
            { name: 'CRIT MASTER', icon: '‚öîÔ∏è', apply: (p) => { p.critChance = 0.5; p.critMultiplier = 5; } },
            { name: 'CHAIN REACTION', icon: '‚ö°', apply: (p) => { p.chainLightning = true; p.chainCount = 5; p.chainDamage = 0.8; } },
            { name: 'STORM BRINGER', icon: 'üå™Ô∏è', apply: (p) => { p.bulletCount += 6; p.bulletSpeed *= 1.5; p.homing = true; p.spread = 0.3; } },
            { name: 'ATOM BOMB', icon: 'üí£', apply: (p) => { p.explosive = true; p.explosionRadius = 200; p.bulletDamage *= 2; p.fireRate *= 2; } },
            { name: 'LIFE STEALER', icon: 'üßõ', apply: (p) => { p.lifesteal = 0.4; p.bulletDamage *= 1.3; } },
            { name: 'GATLING GUN', icon: 'üî´', apply: (p) => { p.bulletCount += randomInt(8, 15); p.spread = 0.4; } },
            { name: 'TIME MASTER', icon: '‚è∞', apply: (p) => { p.timeWarp = true; p.slowRadius = 200; } },
            { name: 'ORBITAL CANNON', icon: 'üõ∏', apply: (p) => { p.orbitalStrike = true; p.strikeTimer = 0; p.strikeDamage = 100; } },
            { name: 'BERSERKER', icon: 'üòà', apply: (p) => { p.fireRate *= 0.25; p.bulletDamage *= 2; p.speed *= 1.8; } },
            { name: 'PIERCER', icon: 'üéØ', apply: (p) => { p.piercing = randomInt(5, 12); p.bulletSpeed *= 1.5; } },
            { name: 'BOOMERANG', icon: 'ü™É', apply: (p) => { p.boomerang = true; p.boomerangTime = 0.6; } },
            { name: 'TOXIC', icon: '‚ò†Ô∏è', apply: (p) => { p.poison = true; p.poisonDamage = randomInt(10, 25); p.poisonDuration = 5; } },
            { name: 'CRYO BLASTER', icon: '‚ùÑÔ∏è', apply: (p) => { p.freeze = true; p.freezeDuration = randomRange(1, 2.5); } },
            { name: 'MINIGUN', icon: 'üî´', apply: (p) => { p.fireRate *= 0.15; p.bulletCount = 1; } },
            { name: 'RAILGUN', icon: '‚ö°', apply: (p) => { p.piercing = 999; p.bulletSpeed *= 4; p.bulletDamage *= 4; p.bulletSize = 12; } },
            { name: 'PINBALL', icon: 'üé±', apply: (p) => { p.ricochet = randomInt(5, 15); p.bulletSpeed *= 1.3; } },
            { name: 'SPIRAL DEATH', icon: 'üåÄ', apply: (p) => { p.spiralShot = true; p.spiralCount = 3; } },
            { name: 'CLONE ARMY', icon: 'üë•', apply: (p) => { p.summonDrones = true; p.maxDrones = randomInt(4, 8); } },
            { name: 'BLACK HOLE', icon: 'üï≥Ô∏è', apply: (p) => { p.blackHoleShot = true; p.blackHolePull = 4; } },
            { name: 'METEOR SHOWER', icon: '‚òÑÔ∏è', apply: (p) => { p.meteorShower = true; p.meteorTimer = 0; } },
            { name: 'BULLET STORM', icon: 'üå™Ô∏è', apply: (p) => { p.bulletCount += 20; p.spread = 1; p.fireRate *= 0.5; } },
            { name: 'OMEGA BEAM', icon: 'üîÜ', apply: (p) => { p.omegaBeam = true; p.beamWidth = 50; } },
        ];

        const BOSS_POWERS = [
            { name: 'BULLET APOCALYPSE', icon: 'üíÄ', attack: (b) => createBulletHell(b, randomInt(30, 60)) },
            { name: 'VOID WALKER', icon: 'üåÄ', attack: (b) => { if (Math.random() < 0.2) teleportBoss(b); createSpiral(b); } },
            { name: 'SPAWNER LORD', icon: 'üëæ', attack: (b) => { spawnMinions(b, randomInt(2, 4)); createBurst(b); } },
            { name: 'LASER GRID', icon: 'üìä', attack: (b) => createLaserGrid(b) },
            { name: 'GRAVITY TITAN', icon: 'üåë', attack: (b) => { b.gravityPull = true; b.gravityStrength = randomRange(0.6, 1.2); createWave(b); } },
            { name: 'FURY MODE', icon: 'üò°', attack: (b) => { if (b.hp < b.maxHp * 0.5) { b.attackSpeed *= 0.7; b.speed *= 1.5; } createRandom(b); } },
            { name: 'BARRIER KING', icon: 'üõ°Ô∏è', attack: (b) => { b.shield = Math.max(b.shield || 0, 150); b.shieldRegen = 10; createBurst(b); } },
            { name: 'MITOSIS', icon: 'üß¨', attack: (b) => { if (!b.cloned && b.hp < b.maxHp * 0.5) { cloneBoss(b, randomInt(2, 4)); b.cloned = true; } createSpiral(b); } },
            { name: 'CHAOS INCARNATE', icon: 'üé≤', attack: (b) => randomMultiAttack(b) },
            { name: 'DIMENSIONAL RIFT', icon: 'üåå', attack: (b) => { b.phasing = Math.random() < 0.5; createRealityTear(b); } },
            { name: 'METEOR CALLER', icon: '‚òÑÔ∏è', attack: (b) => createMeteorStorm(b, randomInt(10, 20)) },
            { name: 'VOID SPHERE', icon: '‚ö´', attack: (b) => createBlackHole(b) },
            { name: 'SUPERNOVA', icon: 'üåü', attack: (b) => { createNova(b); createBurst(b); } },
            { name: 'REALITY BREAKER', icon: 'üí´', attack: (b) => createRealityTear(b) },
            { name: 'ARMAGEDDON', icon: 'üî•', attack: (b) => { createBulletHell(b, 40); createMeteorStorm(b, 15); createSpiral(b); } },
            { name: 'TIME BENDER', icon: '‚è≥', attack: (b) => { createTimeSlow(b); createTracking(b); } },
            { name: 'SHIELD MATRIX', icon: 'üî∑', attack: (b) => { createShieldOrbs(b); createBurst(b); } },
        ];

        let player = null;
        let boss = null;
        let bullets = [];
        let bossBullets = [];
        let particles = [];
        let minions = [];
        let explosions = [];
        let powerUps = [];
        let lightningArcs = [];
        let blackHoles = [];
        let shockwaves = [];
        let drones = [];
        let orbitalStrikes = [];
        let trails = [];

        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(randomRange(min, max + 1));
        }

        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function showNotification(text, duration = 2000) {
            const notif = document.getElementById('notification');
            notif.innerHTML = text;
            notif.style.opacity = '1';
            notif.style.fontSize = randomInt(36, 72) + 'px';
            notif.style.color = randomChoice(NEON_COLORS);
            notif.style.textShadow = `0 0 30px ${randomChoice(NEON_COLORS)}`;
            setTimeout(() => {
                notif.style.opacity = '0';
            }, duration);
        }

        function addScreenShake(intensity) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
        }

        function createPlayer() {
            // RANDOM MULTIPLE POWERS!
            const numPowers = randomInt(3, 6);
            const selectedPowers = [];
            const powersCopy = [...ALL_POWERS];
            
            for (let i = 0; i < numPowers && powersCopy.length > 0; i++) {
                const index = randomInt(0, powersCopy.length - 1);
                selectedPowers.push(powersCopy.splice(index, 1)[0]);
            }

            player = {
                x: canvas.width / 2,
                y: canvas.height / 2,
                hp: randomInt(100, 250),
                maxHp: randomInt(100, 250),
                speed: randomRange(5, 9),
                size: randomInt(12, 18),
                color: randomChoice(NEON_COLORS),
                bulletDamage: randomInt(20, 40),
                bulletSpeed: randomInt(10, 18),
                fireRate: randomRange(0.12, 0.28),
                shootTimer: 0,
                bulletCount: 1,
                bulletSize: 8,
                spread: 0,
                powers: selectedPowers,
                rotation: 0,
                trail: [],
                // Power attributes
                laserMode: false,
                explosive: false,
                homing: false,
                shield: 0,
                maxShield: 0,
                shieldRegen: 0,
                canPhase: false,
                phaseTimer: 0,
                phaseCooldown: 0,
                phaseMax: 0.5,
                critChance: 0,
                critMultiplier: 1,
                chainLightning: false,
                lifesteal: 0,
                piercing: 0,
                boomerang: false,
                poison: false,
                freeze: false,
                ricochet: 0,
                timeWarp: false,
                orbitalStrike: false,
                spiralShot: false,
                summonDrones: false,
                blackHoleShot: false,
                meteorShower: false,
                omegaBeam: false,
                dashPower: false,
                damageMultiplier: randomRange(0.9, 1.6),
                speedMultiplier: randomRange(0.9, 1.5),
            };

            // Apply all powers
            selectedPowers.forEach(power => power.apply(player));
            
            player.hp = player.maxHp;
            player.bulletDamage *= player.damageMultiplier;
            player.speed *= player.speedMultiplier;

            const powerText = selectedPowers.map(p => `${p.icon} ${p.name}`).join(' ‚Ä¢ ');
            showNotification(`‚ö° YOUR POWERS ‚ö°<br><span style="font-size:0.6em">${powerText}</span>`, 4000);
        }

        function createBoss() {
            const numPowers = randomInt(2, 4);
            const selectedPowers = [];
            const powersCopy = [...BOSS_POWERS];
            
            for (let i = 0; i < numPowers && powersCopy.length > 0; i++) {
                const index = randomInt(0, powersCopy.length - 1);
                selectedPowers.push(powersCopy.splice(index, 1)[0]);
            }

            const shapes = ['circle', 'square', 'triangle', 'hexagon', 'star', 'diamond', 'octagon', 'cross', 'pentagon', 'spiral', 'ring'];
            boss = {
                x: randomRange(200, canvas.width - 200),
                y: randomRange(100, 300),
                hp: randomInt(400, 1000) + (bossCount * 100),
                maxHp: randomInt(400, 1000) + (bossCount * 100),
                size: randomInt(60, 140),
                speed: randomRange(3, 9),
                color: randomChoice(NEON_COLORS),
                shape: randomChoice(shapes),
                powers: selectedPowers,
                attackTimer: 0,
                attackSpeed: randomRange(0.25, 1.2),
                movePattern: 0,
                vx: randomRange(-5, 5),
                vy: randomRange(-5, 5),
                damage: randomInt(25, 60) + (bossCount * 5),
                gravityPull: false,
                gravityStrength: 0.5,
                shield: randomInt(0, 300),
                maxShield: randomInt(0, 300),
                shieldRegen: 0,
                cloned: false,
                phasing: false,
                rotation: 0,
                phase: 1,
                trail: [],
            };
            boss.hp = boss.maxHp;
            boss.shield = boss.maxShield;

            const powerText = selectedPowers.map(p => `${p.icon} ${p.name}`).join(' ‚Ä¢ ');
            showNotification(`üíÄ BOSS ${bossCount} üíÄ<br><span style="font-size:0.5em">${powerText}</span>`, 4000);
            addScreenShake(25);
        }

        function startGame() {
            document.getElementById('menu').classList.add('hidden');
            gameState = 'playing';
            score = 0;
            bossCount = 0;
            combo = 0;
            maxCombo = 0;
            ultimateCharge = 0;
            bullets = [];
            bossBullets = [];
            particles = [];
            minions = [];
            explosions = [];
            powerUps = [];
            lightningArcs = [];
            blackHoles = [];
            shockwaves = [];
            drones = [];
            orbitalStrikes = [];
            trails = [];
            createPlayer();
            nextBoss();
        }

        function nextBoss() {
            bossCount++;
            createBoss();
            bossBullets = [];
            minions = [];
            
            // RANDOM EVENTS!
            const eventChance = Math.random();
            if (eventChance < 0.15) {
                timeWarp = 0.3;
                setTimeout(() => timeWarp = 1, 6000);
                showNotification('‚è∞ SLOW MOTION! ‚è∞', 3000);
            } else if (eventChance < 0.3) {
                createRandomPowerUps(randomInt(5, 10));
                showNotification('üíé POWER UP RAIN! üíé', 3000);
            } else if (eventChance < 0.4) {
                player.hp = player.maxHp;
                player.shield = player.maxShield;
                showNotification('‚ù§Ô∏è FULL RESTORE! ‚ù§Ô∏è', 2000);
            } else if (eventChance < 0.5) {
                ultimateCharge = 100;
                showNotification('‚ö° ULTIMATE CHARGED! ‚ö°', 2000);
            } else if (eventChance < 0.6) {
                player.bulletDamage *= 2;
                showNotification('üî• DOUBLE DAMAGE! üî•', 2000);
            }
        }

        function gameOver() {
            gameState = 'menu';
            const menu = document.getElementById('menu');
            menu.classList.remove('hidden');
            const grade = score > 50000 ? 'S+++ GODLIKE' : score > 30000 ? 'S LEGENDARY' : score > 15000 ? 'A AMAZING' : score > 8000 ? 'B GOOD' : 'C DECENT';
            menu.innerHTML = `
                <h1 style="color: #f00; animation: blink 0.5s infinite;">üíÄ DESTROYED üíÄ</h1>
                <p style="color: #f0f; font-size: 36px; margin: 20px 0; text-shadow: 0 0 20px #f0f;">BOSSES: ${bossCount - 1}</p>
                <p style="color: #ff0; font-size: 32px; margin-bottom: 10px; text-shadow: 0 0 20px #ff0;">SCORE: ${score}</p>
                <p style="color: #0ff; font-size: 28px; margin-bottom: 10px;">MAX COMBO: ${maxCombo}x</p>
                <p style="color: #0f0; font-size: 24px; margin-bottom: 30px;">RANK: ${grade}</p>
                <button onclick="startGame()">‚ñ∂ RETRY</button>
            `;
            addScreenShake(60);
        }

        function createRandomPowerUps(count) {
            for (let i = 0; i < count; i++) {
                powerUps.push({
                    x: randomRange(50, canvas.width - 50),
                    y: randomRange(50, canvas.height - 50),
                    type: randomChoice(['health', 'damage', 'speed', 'ultimate', 'shield', 'firerate', 'size']),
                    color: randomChoice(NEON_COLORS),
                    size: 20,
                    rotation: 0,
                    lifetime: 10,
                });
            }
        }

        // ATTACK PATTERNS
        function createBulletHell(boss, count = 30) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + boss.movePattern + randomRange(-0.1, 0.1);
                bossBullets.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * randomRange(4, 7),
                    vy: Math.sin(angle) * randomRange(4, 7),
                    size: randomInt(8, 14),
                    color: boss.color,
                    damage: boss.damage,
                });
            }
            addScreenShake(12);
        }

        function createSpiral(boss) {
            const arms = randomInt(3, 6);
            for (let i = 0; i < arms; i++) {
                const angle = (Math.PI * 2 * i) / arms + boss.movePattern * 3;
                bossBullets.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * 6,
                    vy: Math.sin(angle) * 6,
                    size: 12,
                    color: boss.color,
                    damage: boss.damage,
                });
            }
        }

        function createBurst(boss) {
            const numBullets = randomInt(15, 30);
            for (let i = 0; i < numBullets; i++) {
                const angle = (Math.PI * 2 * i) / numBullets + randomRange(-0.2, 0.2);
                bossBullets.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * randomRange(5, 10),
                    vy: Math.sin(angle) * randomRange(5, 10),
                    size: randomInt(10, 18),
                    color: randomChoice(NEON_COLORS),
                    damage: boss.damage,
                });
            }
        }

        function createWave(boss) {
            for (let i = 0; i < 11; i++) {
                bossBullets.push({
                    x: boss.x + (i - 5) * 50,
                    y: boss.y,
                    vx: (i - 5) * 2.5,
                    vy: 7,
                    size: 16,
                    color: boss.color,
                    damage: boss.damage,
                });
            }
        }

        function createTracking(boss) {
            const dx = player.x - boss.x;
            const dy = player.y - boss.y;
            const angle = Math.atan2(dy, dx);
            for (let i = 0; i < 7; i++) {
                const spread = (i - 3) * 0.15;
                bossBullets.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle + spread) * 8,
                    vy: Math.sin(angle + spread) * 8,
                    size: 14,
                    color: boss.color,
                    damage: boss.damage,
                    homing: true,
                });
            }
        }

        function createRandom(boss) {
            const num = randomInt(10, 25);
            for (let i = 0; i < num; i++) {
                const angle = randomRange(0, Math.PI * 2);
                bossBullets.push({
                    x: boss.x,
                    y: boss.y,
                    vx: Math.cos(angle) * randomRange(4, 12),
                    vy: Math.sin(angle) * randomRange(4, 12),
                    size: randomInt(8, 20),
                    color: randomChoice(NEON_COLORS),
                    damage: boss.damage * randomRange(0.8, 1.5),
                });
            }
        }

        function createLaserGrid(boss) {
            // Horizontal lasers
            for (let i = 0; i < 3; i++) {
                bossBullets.push({
                    x: 0,
                    y: boss.y + (i - 1) * 100,
                    vx: 20,
                    vy: 0,
                    size: 30,
                    color: '#ff0',
                    damage: boss.damage * 1.5,
                    laser: true,
                });
            }
            // Vertical lasers
            for (let i = 0; i < 3; i++) {
                bossBullets.push({
                    x: boss.x + (i - 1) * 100,
                    y: 0,
                    vx: 0,
                    vy: 20,
                    size: 30,
                    color: '#ff0',
                    damage: boss.damage * 1.5,
                    laser: true,
                });
            }
            addScreenShake(18);
        }

        function createMeteorStorm(boss, count = 10) {
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    bossBullets.push({
                        x: randomRange(0, canvas.width),
                        y: -50,
                        vx: randomRange(-4, 4),
                        vy: randomRange(10, 16),
                        size: randomInt(25, 45),
                        color: '#f60',
                        damage: boss.damage * 1.8,
                        explosive: true,
                        rotation: randomRange(0, Math.PI * 2),
                        rotationSpeed: randomRange(-0.2, 0.2),
                    });
                }, i * 100);
            }
        }

        function createBlackHole(boss) {
            blackHoles.push({
                x: randomRange(150, canvas.width - 150),
                y: randomRange(150, canvas.height - 150),
                radius: 0,
                maxRadius: randomInt(100, 180),
                pullStrength: randomRange(3, 6),
                life: randomRange(4, 7),
                color: randomChoice(NEON_COLORS),
                damage: boss.damage * 0.5,
            });
            addScreenShake(25);
        }

        function createNova(boss) {
            for (let wave = 0; wave < 3; wave++) {
                setTimeout(() => {
                    shockwaves.push({
                        x: boss.x,
                        y: boss.y,
                        radius: 0,
                        maxRadius: randomInt(250, 450),
                        speed: randomRange(8, 12),
                        damage: boss.damage * 1.5,
                        color: boss.color,
                        hit: false,
                    });
                }, wave * 300);
            }
            addScreenShake(30);
        }

        function createRealityTear(boss) {
            for (let i = 0; i < 80; i++) {
                bossBullets.push({
                    x: randomRange(0, canvas.width),
                    y: randomRange(0, canvas.height),
                    vx: randomRange(-10, 10),
                    vy: randomRange(-10, 10),
                    size: randomInt(6, 18),
                    color: randomChoice(NEON_COLORS),
                    damage: boss.damage * 0.9,
                });
            }
            addScreenShake(35);
        }

        function createTimeSlow(boss) {
            timeWarp = 0.5;
            setTimeout(() => timeWarp = 1, 3000);
            createTracking(boss);
        }

        function createShieldOrbs(boss) {
            const orbCount = randomInt(5, 8);
            for (let i = 0; i < orbCount; i++) {
                const angle = (Math.PI * 2 * i) / orbCount;
                minions.push({
                    x: boss.x + Math.cos(angle) * 150,
                    y: boss.y + Math.sin(angle) * 150,
                    hp: 50,
                    size: 25,
                    color: boss.color,
                    speed: 0,
                    orbiting: true,
                    orbitAngle: angle,
                    orbitRadius: 150,
                    orbitSpeed: 0.02,
                    shootTimer: randomRange(0, 2),
                });
            }
        }

        function randomMultiAttack(boss) {
            const attacks = [createBulletHell, createSpiral, createBurst, createWave, createTracking, createRandom, createLaserGrid];
            const numAttacks = randomInt(2, 4);
            for (let i = 0; i < numAttacks; i++) {
                randomChoice(attacks)(boss);
            }
        }

        function teleportBoss(boss) {
            createParticles(boss.x, boss.y, boss.color, 50);
            boss.x = randomRange(150, canvas.width - 150);
            boss.y = randomRange(150, canvas.height - 250);
            createParticles(boss.x, boss.y, boss.color, 50);
            addScreenShake(20);
        }

        function spawnMinions(boss, count = 2) {
            for (let i = 0; i < count; i++) {
                if (minions.length < 15) {
                    minions.push({
                        x: boss.x + randomRange(-150, 150),
                        y: boss.y + randomRange(-150, 150),
                        hp: randomInt(50, 100),
                        size: randomInt(20, 35),
                        color: boss.color,
                        speed: randomRange(4, 8),
                        shootTimer: randomRange(0, 1.5),
                        type: randomChoice(['basic', 'fast', 'tank']),
                    });
                }
            }
        }

        function cloneBoss(boss, count = 2) {
            for (let i = 0; i < count; i++) {
                minions.push({
                    x: boss.x + randomRange(-200, 200),
                    y: boss.y + randomRange(-200, 200),
                    hp: boss.hp * 0.35,
                    size: boss.size * 0.65,
                    color: boss.color,
                    speed: boss.speed * 1.3,
                    isBossClone: true,
                    shape: boss.shape,
                    shootTimer: 0,
                });
            }
            addScreenShake(25);
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: randomRange(-12, 12),
                    vy: randomRange(-12, 12),
                    life: randomRange(0.5, 2),
                    color: color || randomChoice(NEON_COLORS),
                    size: randomRange(3, 10),
                });
            }
        }

        function createExplosion(x, y, radius, damage, color) {
            explosions.push({ 
                x, y, radius, 
                currentRadius: 0, 
                color, 
                damage,
                hit: [],
                maxRadius: radius,
            });
            createParticles(x, y, color, 60);
            addScreenShake(Math.min(radius / 3, 40));
        }

        function createChainLightning(from, damage, chain, chainDamage = 0.8) {
            const targets = [boss, ...minions].filter(t => t && t.hp > 0);
            
            targets.sort((a, b) => {
                const distA = Math.hypot(a.x - from.x, a.y - from.y);
                const distB = Math.hypot(b.x - from.x, b.y - from.y);
                return distA - distB;
            });

            let currentDamage = damage;
            for (let i = 0; i < Math.min(chain, targets.length); i++) {
                const target = targets[i];
                lightningArcs.push({
                    x1: from.x,
                    y1: from.y,
                    x2: target.x,
                    y2: target.y,
                    life: 0.4,
                    color: randomChoice(['#0ff', '#ff0', '#f0f']),
                });
                
                if (target === boss) {
                    if (boss.shield > 0) {
                        boss.shield -= currentDamage;
                        if (boss.shield < 0) {
                            boss.hp += boss.shield;
                            boss.shield = 0;
                        }
                    } else {
                        boss.hp -= currentDamage;
                    }
                } else {
                    target.hp -= currentDamage;
                }
                
                createParticles(target.x, target.y, '#0ff', 10);
                from = target;
                currentDamage *= chainDamage;
            }
        }

        // Drawing
        function drawShape(x, y, size, shape, color, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.shadowBlur = 30;
            ctx.shadowColor = color;

            ctx.beginPath();
            switch (shape) {
                case 'circle':
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.rect(-size / 2, -size / 2, size, size);
                    break;
                case 'triangle':
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, size / 2);
                    ctx.lineTo(-size / 2, size / 2);
                    break;
                case 'hexagon':
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = (size / 2) * Math.cos(angle);
                        const py = (size / 2) * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'star':
                    for (let i = 0; i < 10; i++) {
                        const angle = (Math.PI / 5) * i - Math.PI / 2;
                        const r = i % 2 === 0 ? size / 2 : size / 4;
                        const px = r * Math.cos(angle);
                        const py = r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'diamond':
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, 0);
                    ctx.lineTo(0, size / 2);
                    ctx.lineTo(-size / 2, 0);
                    break;
                case 'octagon':
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 4) * i;
                        const px = (size / 2) * Math.cos(angle);
                        const py = (size / 2) * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'cross':
                    const w = size / 3;
                    ctx.rect(-w / 2, -size / 2, w, size);
                    ctx.rect(-size / 2, -w / 2, size, w);
                    break;
                case 'pentagon':
                    for (let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const px = (size / 2) * Math.cos(angle);
                        const py = (size / 2) * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'spiral':
                    for (let i = 0; i < 60; i++) {
                        const angle = i * 0.25;
                        const r = (size / 2) * (i / 60);
                        const px = r * Math.cos(angle);
                        const py = r * Math.sin(angle);
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    break;
                case 'ring':
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    ctx.arc(0, 0, size / 3, 0, Math.PI * 2, true);
                    break;
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        // Main game loop
        function update(dt) {
            dt *= timeWarp;
            
            if (gameState !== 'playing') return;

            backgroundPulse += dt;

            // Screen shake
            if (screenShake.intensity > 0) {
                screenShake.x = randomRange(-screenShake.intensity, screenShake.intensity);
                screenShake.y = randomRange(-screenShake.intensity, screenShake.intensity);
                screenShake.intensity *= 0.88;
            } else {
                screenShake.x = 0;
                screenShake.y = 0;
            }

            // Combo system
            comboTimer -= dt;
            if (comboTimer <= 0) {
                combo = 0;
            }
            maxCombo = Math.max(maxCombo, combo);

            // Player movement
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const mag = Math.sqrt(dx * dx + dy * dy);
                player.x += (dx / mag) * player.speed;
                player.y += (dy / mag) * player.speed;
                
                // Trail effect
                if (Math.random() < 0.3) {
                    trails.push({
                        x: player.x,
                        y: player.y,
                        size: player.size,
                        color: player.color,
                        life: 0.5,
                    });
                }
            }

            player.x = Math.max(player.size, Math.min(canvas.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(canvas.height - player.size, player.y));
            player.rotation += dt * 2;

            // Shield regen
            if (player.shieldRegen && player.shield < player.maxShield) {
                player.shield = Math.min(player.maxShield, player.shield + player.shieldRegen * dt);
            }

            // Ultimate ability (SPACE)
            if (keys[' '] && ultimateCharge >= 100 && !player.ultimateActive) {
                player.ultimateActive = true;
                ultimateCharge = 0;
                
                // MASSIVE SCREEN CLEAR
                createExplosion(player.x, player.y, 600, 300, player.color);
                bossBullets = [];
                for (let i = minions.length - 1; i >= 0; i--) {
                    minions[i].hp -= 200;
                }
                if (boss) {
                    boss.hp -= 150;
                }
                showNotification('üí•‚ö° ULTIMATE UNLEASHED! ‚ö°üí•', 2000);
                addScreenShake(70);
                
                setTimeout(() => player.ultimateActive = false, 800);
            }

            // Player shooting
            player.shootTimer -= dt;
            if (mouse.down && player.shootTimer <= 0) {
                const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                
                if (player.spiralShot) {
                    for (let s = 0; s < player.spiralCount; s++) {
                        for (let i = 0; i < player.bulletCount; i++) {
                            const spreadAngle = angle + (i - (player.bulletCount - 1) / 2) * player.spread + (s * Math.PI * 2 / player.spiralCount);
                            shootBullet(spreadAngle);
                        }
                    }
                } else if (player.omegaBeam) {
                    bullets.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(angle) * 30,
                        vy: Math.sin(angle) * 30,
                        size: player.beamWidth,
                        color: player.color,
                        damage: player.bulletDamage * 3,
                        laser: true,
                        piercing: 999,
                    });
                } else {
                    for (let i = 0; i < player.bulletCount; i++) {
                        const spreadAngle = angle + (i - (player.bulletCount - 1) / 2) * player.spread;
                        shootBullet(spreadAngle);
                    }
                }
                player.shootTimer = player.fireRate;
            }

            function shootBullet(angle) {
                const isCrit = Math.random() < player.critChance;
                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * player.bulletSpeed,
                    vy: Math.sin(angle) * player.bulletSpeed,
                    size: isCrit ? player.bulletSize * 1.5 : player.bulletSize,
                    color: isCrit ? '#ff0' : player.color,
                    damage: player.bulletDamage * (isCrit ? player.critMultiplier : 1),
                    explosive: player.explosive,
                    homing: player.homing,
                    piercing: player.piercing,
                    pierceCount: 0,
                    chainLightning: player.chainLightning,
                    boomerang: player.boomerang,
                    boomerangTimer: 0,
                    poison: player.poison,
                    freeze: player.freeze,
                    ricochet: player.ricochet,
                    ricochetCount: 0,
                    laser: player.laserMode,
                    blackHole: player.blackHoleShot,
                    rotation: angle,
                });
            }

            // Phase ability
            if (player.canPhase) {
                player.phaseCooldown -= dt;
                if (player.phaseTimer > 0) {
                    player.phaseTimer -= dt;
                } else if (keys['shift'] && player.phaseCooldown <= 0) {
                    player.phaseTimer = player.phaseMax;
                    player.phaseCooldown = 2.5;
                    showNotification('üëª PHASE!', 800);
                }
            }

            // Dash ability
            if (player.dashPower && keys['shift'] && player.phaseCooldown <= 0) {
                const dashAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
                player.x += Math.cos(dashAngle) * 100;
                player.y += Math.sin(dashAngle) * 100;
                player.phaseCooldown = 1;
                createParticles(player.x, player.y, player.color, 30);
            }

            // Orbital strike
            if (player.orbitalStrike) {
                player.strikeTimer -= dt;
                if (player.strikeTimer <= 0) {
                    const targetX = boss ? boss.x + randomRange(-100, 100) : randomRange(0, canvas.width);
                    orbitalStrikes.push({
                        x: targetX,
                        y: -50,
                        targetY: randomRange(100, canvas.height - 100),
                        speed: 25,
                        size: 40,
                        damage: player.strikeDamage || 100,
                        color: '#ff0',
                    });
                    player.strikeTimer = 2.5;
                }
            }

            // Meteor shower
            if (player.meteorShower) {
                player.meteorTimer = (player.meteorTimer || 0) - dt;
                if (player.meteorTimer <= 0) {
                    for (let i = 0; i < 3; i++) {
                        bossBullets.push({
                            x: randomRange(0, canvas.width),
                            y: canvas.height + 50,
                            vx: 0,
                            vy: -15,
                            size: 25,
                            color: '#0ff',
                            damage: -50, // Heals!
                            fromPlayer: true,
                        });
                    }
                    player.meteorTimer = 4;
                }
            }

            // Summon drones
            if (player.summonDrones && drones.length < (player.maxDrones || 4)) {
                drones.push({
                    x: player.x + randomRange(-80, 80),
                    y: player.y + randomRange(-80, 80),
                    angle: randomRange(0, Math.PI * 2),
                    speed: 4,
                    orbitRadius: randomRange(60, 100),
                    shootTimer: randomRange(0, 1),
                });
            }

            // Update drones
            drones.forEach(drone => {
                drone.angle += dt * 2.5;
                drone.x = player.x + Math.cos(drone.angle) * drone.orbitRadius;
                drone.y = player.y + Math.sin(drone.angle) * drone.orbitRadius;
                
                drone.shootTimer -= dt;
                if (boss && drone.shootTimer <= 0) {
                    const dx = boss.x - drone.x;
                    const dy = boss.y - drone.y;
                    const angle = Math.atan2(dy, dx);
                    bullets.push({
                        x: drone.x,
                        y: drone.y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        size: 8,
                        color: '#0f0',
                        damage: player.bulletDamage * 0.5,
                    });
                    drone.shootTimer = 0.8;
                }
            });

            // Boss AI
            if (boss) {
                boss.rotation += dt * 1.5;
                boss.x += boss.vx * dt * 60;
                boss.y += boss.vy * dt * 60;

                if (boss.x < boss.size || boss.x > canvas.width - boss.size) boss.vx *= -1;
                if (boss.y < boss.size || boss.y > canvas.height - boss.size) boss.vy *= -1;

                if (Math.random() < 0.015) {
                    boss.vx = randomRange(-boss.speed, boss.speed);
                    boss.vy = randomRange(-boss.speed, boss.speed);
                }

                // Trail
                if (Math.random() < 0.2) {
                    trails.push({
                        x: boss.x,
                        y: boss.y,
                        size: boss.size * 0.8,
                        color: boss.color,
                        life: 0.3,
                    });
                }

                boss.movePattern += dt;
                boss.attackTimer -= dt;
                
                if (boss.attackTimer <= 0) {
                    boss.powers.forEach(power => power.attack(boss));
                    boss.attackTimer = boss.attackSpeed;
                }

                // Boss phases
                const hpPercent = boss.hp / boss.maxHp;
                if (hpPercent < 0.5 && boss.phase === 1) {
                    boss.phase = 2;
                    boss.attackSpeed *= 0.6;
                    boss.speed *= 1.4;
                    showNotification('‚ö†Ô∏èüî• BOSS ENRAGED! üî•‚ö†Ô∏è', 3000);
                    addScreenShake(40);
                    createNova(boss);
                }
                if (hpPercent < 0.25 && boss.phase === 2) {
                    boss.phase = 3;
                    boss.attackSpeed *= 0.7;
                    boss.damage *= 1.5;
                    showNotification('üíÄ‚ö° FINAL FORM! ‚ö°üíÄ', 3000);
                    addScreenShake(50);
                }

                // Shield regen
                if (boss.shieldRegen && boss.shield < boss.maxShield) {
                    boss.shield = Math.min(boss.maxShield, boss.shield + boss.shieldRegen * dt);
                }

                // Gravity pull
                if (boss.gravityPull) {
                    const dx = boss.x - player.x;
                    const dy = boss.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 300) {
                        player.x += (dx / dist) * boss.gravityStrength;
                        player.y += (dy / dist) * boss.gravityStrength;
                    }
                }

                // Status effects
                if (boss.poisoned) {
                    boss.poisonTimer -= dt;
                    boss.hp -= (boss.poisonDamage || 10) * dt;
                    if (Math.random() < 0.1) {
                        createParticles(boss.x, boss.y, '#0f0', 3);
                    }
                    if (boss.poisonTimer <= 0) {
                        boss.poisoned = false;
                    }
                }
                
                if (boss.frozen) {
                    boss.frozenTimer -= dt;
                    if (boss.frozenTimer <= 0) {
                        boss.frozen = false;
                    }
                }
            }

            // Update bullets
            bullets = bullets.filter(b => {
                // Homing
                if (b.homing && boss && boss.hp > 0) {
                    const dx = boss.x - b.x;
                    const dy = boss.y - b.y;
                    const angle = Math.atan2(dy, dx);
                    b.vx += Math.cos(angle) * 0.6;
                    b.vy += Math.sin(angle) * 0.6;
                }

                // Boomerang
                if (b.boomerang) {
                    b.boomerangTimer += dt;
                    if (b.boomerangTimer > (player.boomerangTime || 0.5)) {
                        const dx = player.x - b.x;
                        const dy = player.y - b.y;
                        const angle = Math.atan2(dy, dx);
                        b.vx = Math.cos(angle) * player.bulletSpeed * 1.5;
                        b.vy = Math.sin(angle) * player.bulletSpeed * 1.5;
                    }
                }

                b.x += b.vx;
                b.y += b.vy;
                if (b.rotation !== undefined) b.rotation += 0.2;

                // Black hole effect
                if (b.blackHole && Math.random() < 0.05) {
                    createBlackHole({ x: b.x, y: b.y, damage: b.damage });
                }

                // Hit boss
                if (boss && !boss.phasing && boss.hp > 0) {
                    const dx = b.x - boss.x;
                    const dy = b.y - boss.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < boss.size / 2 + b.size) {
                        let damage = b.damage;
                        
                        if (boss.shield > 0) {
                            boss.shield -= damage;
                            if (boss.shield < 0) {
                                boss.hp += boss.shield;
                                boss.shield = 0;
                            }
                        } else {
                            boss.hp -= damage;
                            
                            if (player.lifesteal) {
                                player.hp = Math.min(player.maxHp, player.hp + damage * player.lifesteal);
                            }
                        }
                        
                        combo++;
                        comboTimer = 3;
                        score += 15 * combo;
                        ultimateCharge = Math.min(100, ultimateCharge + 3);
                        
                        if (b.explosive) {
                            createExplosion(b.x, b.y, player.explosionRadius || 100, b.damage * 0.6, b.color);
                        }
                        
                        if (b.chainLightning) {
                            createChainLightning(b, b.damage * (player.chainDamage || 0.7), player.chainCount || 3);
                        }
                        
                        if (b.poison) {
                            boss.poisoned = true;
                            boss.poisonTimer = player.poisonDuration || 3;
                            boss.poisonDamage = player.poisonDamage || 10;
                        }
                        
                        if (b.freeze) {
                            boss.frozen = true;
                            boss.frozenTimer = player.freezeDuration || 1;
                        }
                        
                        createParticles(b.x, b.y, b.color, 18);
                        
                        if (boss.hp <= 0) {
                            createExplosion(boss.x, boss.y, boss.size * 3, 0, boss.color);
                            score += 2000 * bossCount;
                            combo += 100;
                            showNotification(`üíÄ‚ö° BOSS DESTROYED! ‚ö°üíÄ<br>+${2000 * bossCount} POINTS!`, 3000);
                            createRandomPowerUps(randomInt(4, 7));
                            setTimeout(() => nextBoss(), 2500);
                            boss = null;
                        }
                        
                        // Piercing
                        if (b.piercing > b.pierceCount) {
                            b.pierceCount++;
                            return true;
                        }
                        
                        // Ricochet
                        if (b.ricochet > b.ricochetCount) {
                            b.ricochetCount++;
                            b.vx = randomRange(-player.bulletSpeed, player.bulletSpeed);
                            b.vy = randomRange(-player.bulletSpeed, player.bulletSpeed);
                            return true;
                        }
                        
                        return false;
                    }
                }

                // Hit minions
                for (let i = minions.length - 1; i >= 0; i--) {
                    const m = minions[i];
                    const dx = b.x - m.x;
                    const dy = b.y - m.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < m.size / 2 + b.size) {
                        m.hp -= b.damage;
                        combo++;
                        comboTimer = 3;
                        score += 8 * combo;
                        ultimateCharge = Math.min(100, ultimateCharge + 1);
                        
                        createParticles(b.x, b.y, m.color, 12);
                        
                        if (m.hp <= 0) {
                            createExplosion(m.x, m.y, m.size * 1.5, 0, m.color);
                            minions.splice(i, 1);
                            score += 150;
                            
                            if (Math.random() < 0.25) {
                                powerUps.push({
                                    x: m.x,
                                    y: m.y,
                                    type: randomChoice(['health', 'damage', 'ultimate', 'speed']),
                                    color: randomChoice(NEON_COLORS),
                                    size: 18,
                                    rotation: 0,
                                    lifetime: 8,
                                });
                            }
                        }
                        
                        if (b.piercing > b.pierceCount) {
                            b.pierceCount++;
                            return true;
                        }
                        
                        return false;
                    }
                }

                // Boomerang return
                if (b.boomerang && b.boomerangTimer > (player.boomerangTime || 0.5)) {
                    const dx = player.x - b.x;
                    const dy = player.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < player.size) {
                        return false;
                    }
                }

                return b.x > -150 && b.x < canvas.width + 150 && b.y > -150 && b.y < canvas.height + 150;
            });

            // Update boss bullets
            bossBullets = bossBullets.filter(b => {
                if (boss && boss.frozen && !b.fromPlayer) {
                    return true;
                }
                
                if (b.homing) {
                    const dx = player.x - b.x;
                    const dy = player.y - b.y;
                    const angle = Math.atan2(dy, dx);
                    b.vx += Math.cos(angle) * 0.3;
                    b.vy += Math.sin(angle) * 0.3;
                }
                
                b.x += b.vx;
                b.y += b.vy;
                if (b.rotationSpeed) b.rotation = (b.rotation || 0) + b.rotationSpeed;

                // Hit player
                if (player.phaseTimer <= 0) {
                    const dx = b.x - player.x;
                    const dy = b.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < player.size + b.size) {
                        let damage = b.damage;
                        
                        if (b.fromPlayer) {
                            // Healing meteor
                            player.hp = Math.min(player.maxHp, player.hp - damage);
                            createParticles(player.x, player.y, '#0f0', 20);
                            showNotification('‚ù§Ô∏è +50 HP!', 1000);
                            return false;
                        }
                        
                        if (player.shield > 0) {
                            player.shield -= damage;
                            if (player.shield < 0) {
                                player.hp += player.shield;
                                player.shield = 0;
                            }
                        } else {
                            player.hp -= damage;
                        }
                        
                        combo = 0;
                        createParticles(b.x, b.y, b.color, 15);
                        addScreenShake(12);
                        
                        if (player.hp <= 0) {
                            gameOver();
                        }
                        
                        if (b.explosive) {
                            createExplosion(b.x, b.y, 80, 0, b.color);
                        }
                        
                        return false;
                    }
                }

                return b.x > -200 && b.x < canvas.width + 200 && b.y > -200 && b.y < canvas.height + 200;
            });

            // Update minions
            minions.forEach(m => {
                if (m.orbiting) {
                    m.orbitAngle += m.orbitSpeed;
                    if (boss) {
                        m.x = boss.x + Math.cos(m.orbitAngle) * m.orbitRadius;
                        m.y = boss.y + Math.sin(m.orbitAngle) * m.orbitRadius;
                    }
                } else {
                    const dx = player.x - m.x;
                    const dy = player.y - m.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        m.x += (dx / dist) * m.speed;
                        m.y += (dy / dist) * m.speed;
                    }
                }

                m.shootTimer -= dt;
                if (m.shootTimer <= 0) {
                    const dx = player.x - m.x;
                    const dy = player.y - m.y;
                    const angle = Math.atan2(dy, dx);
                    bossBullets.push({
                        x: m.x,
                        y: m.y,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        size: 10,
                        color: m.color,
                        damage: 20,
                    });
                    m.shootTimer = randomRange(1.5, 3);
                }
            });

            // Update orbital strikes
            orbitalStrikes = orbitalStrikes.filter(strike => {
                strike.y += strike.speed;
                
                if (strike.y >= strike.targetY) {
                    createExplosion(strike.x, strike.y, 120, strike.damage, strike.color);
                    return false;
                }
                
                return true;
            });

            // Update explosions
            explosions = explosions.filter(e => {
                e.currentRadius += 20;
                
                if (boss && !e.hit.includes(boss) && boss.hp > 0) {
                    const dx = boss.x - e.x;
                    const dy = boss.y - e.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < e.currentRadius + boss.size / 2 && e.currentRadius < e.maxRadius) {
                        if (boss.shield > 0) {
                            boss.shield -= e.damage;
                            if (boss.shield < 0) {
                                boss.hp += boss.shield;
                                boss.shield = 0;
                            }
                        } else {
                            boss.hp -= e.damage;
                        }
                        e.hit.push(boss);
                    }
                }
                
                minions.forEach(m => {
                    if (!e.hit.includes(m)) {
                        const dx = m.x - e.x;
                        const dy = m.y - e.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < e.currentRadius + m.size / 2 && e.currentRadius < e.maxRadius) {
                            m.hp -= e.damage;
                            e.hit.push(m);
                        }
                    }
                });
                
                return e.currentRadius < e.maxRadius;
            });

            // Update particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.life -= dt * 1.2;
                return p.life > 0;
            });

            // Update trails
            trails = trails.filter(t => {
                t.life -= dt * 2;
                return t.life > 0;
            });

            // Update power-ups
            powerUps = powerUps.filter(pu => {
                pu.rotation += dt * 4;
                pu.lifetime -= dt;
                
                if (pu.lifetime <= 0) return false;
                
                const dx = player.x - pu.x;
                const dy = player.y - pu.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + pu.size) {
                    switch (pu.type) {
                        case 'health':
                            player.hp = Math.min(player.maxHp, player.hp + 75);
                            showNotification('‚ù§Ô∏è +75 HP!', 1500);
                            break;
                        case 'damage':
                            player.bulletDamage *= 1.4;
                            showNotification('‚öîÔ∏è DAMAGE UP!', 1500);
                            break;
                        case 'speed':
                            player.speed *= 1.25;
                            showNotification('‚ö° SPEED UP!', 1500);
                            break;
                        case 'ultimate':
                            ultimateCharge = Math.min(100, ultimateCharge + 40);
                            showNotification('üíé ULTIMATE +40%!', 1500);
                            break;
                        case 'shield':
                            player.shield = Math.max(player.shield, 100);
                            player.maxShield = Math.max(player.maxShield, 100);
                            showNotification('üõ°Ô∏è SHIELD!', 1500);
                            break;
                        case 'firerate':
                            player.fireRate *= 0.8;
                            showNotification('üî´ FIRE RATE UP!', 1500);
                            break;
                        case 'size':
                            player.bulletSize *= 1.3;
                            showNotification('üìè BIGGER BULLETS!', 1500);
                            break;
                    }
                    createParticles(pu.x, pu.y, pu.color, 25);
                    addScreenShake(8);
                    return false;
                }
                
                return true;
            });

            // Update black holes
            blackHoles = blackHoles.filter(bh => {
                bh.radius = Math.min(bh.radius + 8, bh.maxRadius);
                bh.life -= dt;
                
                // Pull player
                const dx = bh.x - player.x;
                const dy = bh.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < bh.maxRadius && player.phaseTimer <= 0) {
                    player.x += (dx / dist) * bh.pullStrength;
                    player.y += (dy / dist) * bh.pullStrength;
                    
                    if (dist < 50 && bh.damage) {
                        player.hp -= bh.damage * dt;
                    }
                }
                
                // Pull bullets
                bullets.forEach(b => {
                    const dx = bh.x - b.x;
                    const dy = bh.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bh.maxRadius) {
                        b.vx += (dx / dist) * 0.8;
                        b.vy += (dy / dist) * 0.8;
                    }
                });
                
                bossBullets.forEach(b => {
                    const dx = bh.x - b.x;
                    const dy = bh.y - b.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < bh.maxRadius) {
                        b.vx += (dx / dist) * 0.6;
                        b.vy += (dy / dist) * 0.6;
                    }
                });
                
                return bh.life > 0;
            });

            // Update shockwaves
            shockwaves = shockwaves.filter(sw => {
                sw.radius += sw.speed;
                
                if (sw.radius < sw.maxRadius) {
                    const dx = player.x - sw.x;
                    const dy = player.y - sw.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (Math.abs(dist - sw.radius) < 25 && !sw.hit && player.phaseTimer <= 0) {
                        if (player.shield > 0) {
                            player.shield -= sw.damage;
                            if (player.shield < 0) {
                                player.hp += player.shield;
                                player.shield = 0;
                            }
                        } else {
                            player.hp -= sw.damage;
                        }
                        createParticles(player.x, player.y, sw.color, 25);
                        addScreenShake(18);
                        sw.hit = true;
                        
                        if (player.hp <= 0) {
                            gameOver();
                        }
                    }
                }
                
                return sw.radius < sw.maxRadius;
            });

            // Update lightning arcs
            lightningArcs = lightningArcs.filter(la => {
                la.life -= dt;
                return la.life > 0;
            });
        }

        function draw() {
            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);
            
            // Dynamic background
            const pulseIntensity = Math.sin(backgroundPulse) * 0.05 + 0.05;
            const bgGradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
            bgGradient.addColorStop(0, `rgba(0, 0, 0, 1)`);
            bgGradient.addColorStop(1, `rgba(0, 20, 40, ${pulseIntensity})`);
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Animated grid
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + pulseIntensity})`;
            ctx.lineWidth = 1;
            const offset = (Date.now() * 0.03) % 50;
            for (let x = -offset; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = -offset; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            if (gameState !== 'playing') {
                ctx.restore();
                return;
            }

            // Draw trails
            trails.forEach(t => {
                ctx.globalAlpha = t.life * 0.4;
                drawShape(t.x, t.y, t.size, 'circle', t.color, 0);
                ctx.globalAlpha = 1;
            });

            // Draw black holes
            blackHoles.forEach(bh => {
                for (let i = 3; i > 0; i--) {
                    ctx.strokeStyle = bh.color;
                    ctx.lineWidth = 10;
                    ctx.shadowBlur = 50;
                    ctx.shadowColor = bh.color;
                    ctx.globalAlpha = 0.3 * i;
                    ctx.beginPath();
                    ctx.arc(bh.x, bh.y, bh.radius * (i * 0.3), 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });

            // Draw shockwaves
            shockwaves.forEach(sw => {
                ctx.strokeStyle = sw.color;
                ctx.lineWidth = 12;
                ctx.shadowBlur = 35;
                ctx.shadowColor = sw.color;
                ctx.globalAlpha = 1 - (sw.radius / sw.maxRadius);
                ctx.beginPath();
                ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });

            // Draw explosions
            explosions.forEach(e => {
                ctx.strokeStyle = e.color;
                ctx.lineWidth = 10;
                ctx.shadowBlur = 50;
                ctx.shadowColor = e.color;
                ctx.globalAlpha = 1 - (e.currentRadius / e.maxRadius);
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.currentRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });

            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.shadowBlur = 20;
                ctx.shadowColor = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            });

            // Draw lightning arcs
            lightningArcs.forEach(la => {
                ctx.strokeStyle = la.color;
                ctx.lineWidth = 5;
                ctx.shadowBlur = 25;
                ctx.shadowColor = la.color;
                ctx.globalAlpha = la.life * 3;
                ctx.beginPath();
                ctx.moveTo(la.x1, la.y1);
                
                const segments = 8;
                for (let i = 1; i < segments; i++) {
                    const t = i / segments;
                    const x = la.x1 + (la.x2 - la.x1) * t + randomRange(-20, 20);
                    const y = la.y1 + (la.y2 - la.y1) * t + randomRange(-20, 20);
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(la.x2, la.y2);
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            });

            // Draw bullets
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowBlur = 30;
                ctx.shadowColor = b.color;
                
                if (b.laser) {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    if (b.rotation !== undefined) ctx.rotate(b.rotation);
                    ctx.fillRect(-b.size, -b.size/4, b.size*2, b.size/2);
                    ctx.restore();
                } else {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if (b.homing) {
                    ctx.strokeStyle = b.color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                ctx.shadowBlur = 0;
            });

            bossBullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.shadowBlur = 25;
                ctx.shadowColor = b.color;
                
                if (b.laser) {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.fillRect(-b.size, -b.size/3, b.size*3, b.size/1.5);
                    ctx.restore();
                } else if (b.explosive) {
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    if (b.rotation !== undefined) ctx.rotate(b.rotation);
                    drawShape(0, 0, b.size, 'star', b.color, 0);
                    ctx.restore();
                } else {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.shadowBlur = 0;
            });

            // Draw orbital strikes
            orbitalStrikes.forEach(strike => {
                ctx.fillStyle = strike.color;
                ctx.shadowBlur = 40;
                ctx.shadowColor = strike.color;
                drawShape(strike.x, strike.y, strike.size, 'star', strike.color, Date.now() * 0.01);
                ctx.shadowBlur = 0;
            });

            // Draw power-ups
            powerUps.forEach(pu => {
                const pulse = Math.sin(Date.now() * 0.005) * 0.2 + 1;
                drawShape(pu.x, pu.y, pu.size * 2 * pulse, 'star', pu.color, pu.rotation);
            });

            // Draw drones
            drones.forEach(drone => {
                drawShape(drone.x, drone.y, 18, 'diamond', '#0f0', drone.angle);
            });

            // Draw minions
            minions.forEach(m => {
                if (m.isBossClone) {
                    drawShape(m.x, m.y, m.size, m.shape, m.color, Date.now() * 0.002);
                } else {
                    drawShape(m.x, m.y, m.size, 'triangle', m.color, Math.atan2(player.y - m.y, player.x - m.x) + Math.PI/2);
                }
            });

            // Draw boss
            if (boss) {
                if (boss.phasing) ctx.globalAlpha = 0.3;
                if (boss.frozen) {
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#0ff';
                }
                if (boss.poisoned) {
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#0f0';
                }
                
                drawShape(boss.x, boss.y, boss.size, boss.shape, boss.color, boss.rotation);
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                // Boss health bar
                const barWidth = 600;
                const barHeight = 35;
                const barX = (canvas.width - barWidth) / 2;
                const barY = 50;

                ctx.fillStyle = '#111';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                if (boss.shield > 0 && boss.maxShield > 0) {
                    ctx.fillStyle = '#0ff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#0ff';
                    ctx.fillRect(barX, barY, barWidth * (boss.shield / boss.maxShield), barHeight);
                }

                ctx.fillStyle = boss.color;
                ctx.shadowBlur = 25;
                ctx.shadowColor = boss.color;
                ctx.fillRect(barX, barY, barWidth * (boss.hp / boss.maxHp), barHeight);
                ctx.shadowBlur = 0;

                ctx.strokeStyle = boss.color;
                ctx.lineWidth = 4;
                ctx.strokeRect(barX, barY, barWidth, barHeight);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px monospace';
                ctx.textAlign = 'center';
                const powerText = boss.powers.map(p => `${p.icon} ${p.name}`).join(' ‚Ä¢ ');
                ctx.fillText(powerText, canvas.width / 2, barY - 10);
                ctx.fillText(`BOSS ${bossCount}`, canvas.width / 2, barY + 25);
                
                if (boss.phase > 1) {
                    ctx.fillStyle = '#f00';
                    ctx.font = 'bold 20px monospace';
                    ctx.fillText(boss.phase === 3 ? '‚ö° FINAL FORM ‚ö°' : 'üî• ENRAGED üî•', canvas.width / 2, barY + barHeight + 30);
                }
            }

            // Draw player
            if (player.phaseTimer > 0) ctx.globalAlpha = 0.3;
            if (player.ultimateActive) {
                ctx.shadowBlur = 80;
                ctx.shadowColor = '#fff';
            }
            
            drawShape(player.x, player.y, player.size * 2.5, 'circle', player.color, player.rotation);
            
            // Player shield visual
            if (player.shield > 0) {
                ctx.strokeStyle = '#0fa';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#0fa';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size * 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Crosshair
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#fff';
            ctx.beginPath();
            ctx.moveTo(mouse.x - 25, mouse.y);
            ctx.lineTo(mouse.x + 25, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 25);
            ctx.lineTo(mouse.x, mouse.y + 25);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 30, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Player health bar
            const pBarWidth = 400;
            const pBarHeight = 30;
            const pBarX = 40;
            const pBarY = canvas.height - 60;

            ctx.fillStyle = '#111';
            ctx.fillRect(pBarX, pBarY, pBarWidth, pBarHeight);
            
            if (player.shield > 0 && player.maxShield > 0) {
                ctx.fillStyle = '#0fa';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0fa';
                ctx.fillRect(pBarX, pBarY, pBarWidth * (player.shield / player.maxShield), pBarHeight);
            }

            ctx.fillStyle = player.color;
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.fillRect(pBarX, pBarY, pBarWidth * Math.max(0, player.hp / player.maxHp), pBarHeight);
            ctx.shadowBlur = 0;

            ctx.strokeStyle = player.color;
            ctx.lineWidth = 4;
            ctx.strokeRect(pBarX, pBarY, pBarWidth, pBarHeight);

            // Ultimate bar
            const ultBarY = pBarY + 40;
            ctx.fillStyle = '#111';
            ctx.fillRect(pBarX, ultBarY, pBarWidth, 20);
            
            const ultGradient = ctx.createLinearGradient(pBarX, 0, pBarX + pBarWidth, 0);
            ultGradient.addColorStop(0, '#ff0');
            ultGradient.addColorStop(0.5, '#f0f');
            ultGradient.addColorStop(1, '#0ff');
            ctx.fillStyle = ultGradient;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ff0';
            ctx.fillRect(pBarX, ultBarY, pBarWidth * (ultimateCharge / 100), 20);
            ctx.shadowBlur = 0;
            
            ctx.strokeStyle = ultimateCharge >= 100 ? '#fff' : '#ff0';
            ctx.lineWidth = 3;
            ctx.strokeRect(pBarX, ultBarY, pBarWidth, 20);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(ultimateCharge >= 100 ? '‚ö° PRESS SPACE! ‚ö°' : `ULTIMATE: ${Math.floor(ultimateCharge)}%`, pBarX + pBarWidth / 2, ultBarY + 15);

            ctx.restore();

            // UI
            const powerListHTML = player.powers.map(p => `<span style="color: ${player.color};">‚ñ∏ ${p.icon} ${p.name}</span>`).join('<br>');
            document.getElementById('stats').innerHTML = `
                <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px; color: ${player.color}; text-shadow: 0 0 15px ${player.color};">
                    YOUR POWERS:
                </div>
                <div style="font-size: 14px; line-height: 1.8; margin-bottom: 12px;">
                    ${powerListHTML}
                </div>
                <div style="color: #fff; margin-top: 12px;">HP: ${Math.floor(Math.max(0, player.hp))}/${player.maxHp}</div>
                ${player.shield > 0 ? `<div style="color: #0fa;">SHIELD: ${Math.floor(player.shield)}</div>` : ''}
                <div style="color: #0ff; margin-top: 12px; font-size: 18px; text-shadow: 0 0 10px #0ff;">SCORE: ${score}</div>
                <div style="color: #f0f; font-size: 16px;">BOSS: ${bossCount}</div>
            `;

            // Combo
            if (combo > 0) {
                const comboSize = Math.min(40 + combo, 80);
                document.getElementById('combo').innerHTML = `
                    <div style="color: #ff0; font-size: ${comboSize}px; font-weight: bold; text-shadow: 0 0 40px #ff0, 0 0 80px #f0f;">
                        ${combo}x COMBO!
                    </div>
                `;
            } else {
                document.getElementById('combo').innerHTML = '';
            }
        }

        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const dt = Math.min((now - lastTime) / 1000, 0.05);
            lastTime = now;

            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.down = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouse.down = false;
        });

        canvas.addEventListener('mouseleave', () => {
            mouse.down = false;
        });

        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        gameLoop();
    </script>
</body>
</html>
